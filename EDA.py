# -*- coding: utf-8 -*-
"""EDA.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1voZamIlSQZDbhknRGQJl8IpGynJpxjn2
"""

import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns
import numpy as np
from textblob import TextBlob
from scipy.stats import pearsonr, skew, kurtosis

reviews_df = pd.read_csv('/content/Cleaned_Data.csv')

reviews_df.head(10)

product_mapping = {
    'B0C8PR4W22': 'Beats Pro (DRE)',
    'B0BXYCS74H': 'Sony XM5 (SONY)',
    'B0B349KKSV': 'Bowers & Wilkins Px8 (Bowers & Wilkins)',
    'B0CCZ1L489': 'Bose QuietComfort (BOSE)',
    'B0B6GHW1SX': 'Momentum 4 (Sennheiser)',
    'B07NM3RSRQ': 'Soundcore Anker Life Q20',
    'B08YJ3W1HB': 'Bang & Olufsen Beoplay HX',
    'B0863FR3S9': 'Sony WH-1000XM4',
    'B07Q9MJKBV': 'Bose Headphones 700',
    'B07YVYZ8T5': 'Beats Solo3'
}


# Load your dataset or use your existing DataFrame
reviews_df = pd.read_csv('/content/Cleaned_Data.csv')

# Group by product_id and calculate the mean rating for each product
mean_ratings = reviews_df.groupby('product_id')['rating'].mean().reset_index()

# Map product_id to product_name using product_mapping
mean_ratings['product_name'] = mean_ratings['product_id'].map(product_mapping)

# Print the mean ratings for each product with product_id and product_name
print("Mean ratings for each product:")
print(mean_ratings[['product_id', 'product_name', 'rating']])

mean_ratings = reviews_df.groupby('product_id')['rating'].mean()

# Convert mean_ratings to a DataFrame and reset index
mean_ratings_df = mean_ratings.reset_index()


# Calculate statistical measures
mean_value = reviews_df['rating'].mean()
median_value = reviews_df['rating'].median()
mode_value = reviews_df['rating'].mode()[0]  # Mode may have multiple values, so we take the first one
variance_value = reviews_df['rating'].var()
std_deviation_value = reviews_df['rating'].std()

print("=============================")
print("Mean:", mean_value)
print("Median:", median_value)
print("Mode:", mode_value)
print("Variance:", variance_value)
print("Standard Deviation:", std_deviation_value)

# Merge with product names using the product_mapping dictionary
mean_ratings_df['product_name'] = mean_ratings_df['product_id'].map(product_mapping)

# Plotting
plt.figure(figsize=(12, 6))

# Bar chart
plt.bar(mean_ratings_df['product_name'], mean_ratings_df['rating'], color='skyblue')

# Set labels and title
plt.xlabel('Product Name')
plt.ylabel('Mean Rating')
plt.title('Mean Ratings for Each Product')

# Show plot
plt.xticks(rotation=45)
plt.tight_layout()
plt.show()

"""Product Ratings Summary
Product ID	Product Name	Rating
B07NM3RSRQ	Soundcore Anker Life Q20	4.70
B07Q9MJKBV	Bose Headphones 700	4.06
B07YVYZ8T5	Beats Solo3	4.68
B0863FR3S9	Sony WH-1000XM4	4.60
B08YJ3W1HB	Bang & Olufsen Beoplay HX	3.69
B0B349KKSV	Bowers & Wilkins Px8 (Bowers & Wilkins)	3.67
B0B6GHW1SX	Momentum 4 (Sennheiser)	4.31
B0BXYCS74H	Sony XM5 (SONY)	4.42
B0C8PR4W22	Beats Pro (DRE)	4.72
B0CCZ1L489	Bose QuietComfort (BOSE)	4.41

Statistical Insights:

Mean Rating: 4.33

The average rating across all products is 4.33, reflecting a generally positive sentiment from users.
Median Rating: 5.0

The median rating is 5.0, suggesting that half of the products are rated 5 or higher, indicating a strong positive skew.
Mode Rating: 5

The most frequently occurring rating is 5, further emphasizing that users often rate these products very highly.
Variance: 1.00

The variance indicates some degree of spread in the ratings. A higher variance suggests that there is more diversity in user opinions.
Standard Deviation: 1.00

The standard deviation is approximately 1.00, highlighting the average deviation from the mean rating. It shows that while most ratings are positive, there are some notable differences in how products are perceived.
Comparison Insights:
Top Performers:

Beats Pro (DRE) and Soundcore Anker Life Q20 are leading with ratings of 4.72 and 4.70, respectively. These products have received the highest praise from users, suggesting strong overall satisfaction.
Mid-Tier Products:

Sony WH-1000XM4 and Beats Solo3 are also performing well with ratings above 4.50. These products are seen as high-quality options but do not reach the top tier.
Lower Ratings:

Bang & Olufsen Beoplay HX and Bowers & Wilkins Px8 have lower ratings at 3.69 and 3.67, respectively. These products might be experiencing issues that affect user satisfaction, or they may not meet the expectations set by other high-rated products.
Consistency:

The majority of products have ratings clustered around the high 4s, indicating overall positive feedback with a few exceptions. The standard deviation shows that while the ratings are generally high, there are still notable differences in user experiences.
"""

product_mapping = {
    'B0C8PR4W22': 'Beats Pro',
    'B0BXYCS74H': 'Sony XM5',
    'B0B349KKSV': 'Bowers & Wilkins Px8',
    'B0CCZ1L489': 'Bose QuietComfort',
    'B0B6GHW1SX': 'Momentum 4',
    'B07NM3RSRQ': 'Soundcore Anker Life',
    'B08YJ3W1HB': 'Bang & Olufsen Beoplay HX',
    'B0863FR3S9': 'Sony WH-1000XM4',
    'B07Q9MJKBV': 'Bose Headphones 700',
    'B07YVYZ8T5': 'Beats Solo3'
}


# Group by product_id and create histograms for ratings distribution
fig, axes = plt.subplots(nrows=2, ncols=5, figsize=(20, 10))  # Adjust nrows and ncols based on your number of products
axes = axes.ravel()  # Flatten the 2D array of axes

# Iterate over each product_id and plot its rating distribution
for i, (product_id, group) in enumerate(reviews_df.groupby('product_id')):
    ax = axes[i]
    ax.hist(group['rating'], bins=5, range=(1, 6), edgecolor='black', alpha=0.7)

    # Use product_mapping to get product name for labeling
    product_name = product_mapping.get(product_id, 'Unknown Product')

    ax.set_title(f'Rating Distribution - {product_name}')
    ax.set_xlabel('Rating')
    ax.set_ylabel('Frequency')
    ax.set_xticks(range(1, 6))  # Show ticks for each rating from 1 to 5
    ax.grid(axis='y', linestyle='--', alpha=0.7)

plt.tight_layout()
plt.show()

# Load your dataset
reviews_df = pd.read_csv('/content/Cleaned_Data.csv')

# Convert the 'timestamp' column to datetime
reviews_df['timestamp'] = pd.to_datetime(reviews_df['timestamp'])

# Extract the year-month from the timestamp
reviews_df['year_month'] = reviews_df['timestamp'].dt.to_period('M')

# Group by product_id and year_month to calculate average rating
avg_ratings_over_time = reviews_df.groupby(['product_id', 'year_month'])['rating'].mean().reset_index()

# Convert the 'year_month' column back to string for plotting purposes
avg_ratings_over_time['year_month'] = avg_ratings_over_time['year_month'].astype(str)

# Create a product mapping dictionary
product_mapping = {
    'B0C8PR4W22': 'Beats Pro (DRE)',
    'B0BXYCS74H': 'Sony XM5 (SONY)',
    'B0B349KKSV': 'Bowers & Wilkins Px8 (Bowers & Wilkins)',
    'B0CCZ1L489': 'Bose QuietComfort (BOSE)',
    'B0B6GHW1SX': 'Momentum 4 (Sennheiser)',
    'B07NM3RSRQ': 'Soundcore Anker Life Q20',
    'B08YJ3W1HB': 'Bang & Olufsen Beoplay HX',
    'B0863FR3S9': 'Sony WH-1000XM4',
    'B07Q9MJKBV': 'Bose Headphones 700',
    'B07YVYZ8T5': 'Beats Solo3'
}

# Plotting line plots for each product
for product_id, product_name in product_mapping.items():
    product_data = avg_ratings_over_time[avg_ratings_over_time['product_id'] == product_id]

    plt.figure(figsize=(10, 6))
    plt.plot(product_data['year_month'], product_data['rating'], marker='o', linestyle='-', color='b')
    plt.title(f'Average Ratings Over Time for {product_name}')
    plt.xlabel('Time (Year-Month)')
    plt.ylabel('Average Rating')
    plt.xticks(rotation=45)
    plt.grid(True)
    plt.tight_layout()
    plt.show()

reviews_df = pd.read_csv('/content/Cleaned_Data.csv', usecols=['rating', 'is_verified', 'helpful_count'])

# Calculate correlation matrix
corr_matrix = reviews_df.corr()

# Plotting the heatmap
plt.figure(figsize=(10, 8))
sns.heatmap(corr_matrix, annot=True, cmap='coolwarm', fmt='.2f', linewidths=0.5)
plt.title('Correlation Matrix')
plt.show()

reviews_df = pd.read_csv('/content/Cleaned_Data.csv')

# Ensure 'helpful_count' is numeric
reviews_df['helpful_count'] = pd.to_numeric(reviews_df['helpful_count'], errors='coerce')

# Function to calculate correlation
def calculate_correlation(df, column1, column2):
    return df[column1].corr(df[column2])

# Calculate correlation between 'rating' and 'helpful_count'
correlation_helpful_count = calculate_correlation(reviews_df, 'rating', 'helpful_count')
print(f"Correlation between 'rating' and 'helpful_count': {correlation_helpful_count:.2f}")

"""Overview:
The correlation coefficient between 'rating' and 'helpful_count' is -0.10. This value provides insight into the relationship between how highly a product is rated and the number of users who found the review helpful.

Interpretation:

Correlation Value:
-0.10 indicates a very weak negative correlation between 'rating' and 'helpful_count'. In statistical terms, this means that there is a slight tendency for higher-rated products to be associated with a lower number of "helpful" votes on their reviews, but the relationship is not strong.
Implications:

Minimal Influence: The weak negative correlation suggests that the overall product rating does not significantly impact the number of users who find reviews helpful. This implies that a product’s rating and the perceived usefulness of its reviews are not strongly linked.
User Behavior: Users might rate products highly based on their own experiences or expectations, but this doesn’t necessarily mean that the reviews are perceived as more helpful. Alternatively, reviews could be deemed helpful regardless of the rating, possibly due to the content of the review rather than the rating itself.
Review Quality: The effectiveness of reviews in aiding purchase decisions may depend more on the content and detail of the reviews rather than the rating itself.
"""

# Load the dataset (assuming 'Cleaned_Data.csv' contains your data)
reviews_df = pd.read_csv('/content/Cleaned_Data.csv')

# Convert 'timestamp' to datetime format
reviews_df['timestamp'] = pd.to_datetime(reviews_df['timestamp'])

# Plotting monthly ratings
reviews_df['year_month'] = reviews_df['timestamp'].dt.to_period('M')
monthly_ratings = reviews_df.groupby('year_month')['rating'].mean().reset_index()

plt.figure(figsize=(14, 6))
plt.plot(monthly_ratings['year_month'].astype(str), monthly_ratings['rating'], marker='o', linestyle='-')
plt.xticks(rotation=45)
plt.xlabel('Time')
plt.ylabel('Average Rating')
plt.title('Average Rating Over Time')
plt.grid(True)
plt.show()

# Create a product mapping dictionary
product_mapping = {
    'B0C8PR4W22': 'Beats Pro (DRE)',
    'B0BXYCS74H': 'Sony XM5 (SONY)',
    'B0B349KKSV': 'Bowers & Wilkins Px8 (Bowers & Wilkins)',
    'B0CCZ1L489': 'Bose QuietComfort (BOSE)',
    'B0B6GHW1SX': 'Momentum 4 (Sennheiser)',
    'B07NM3RSRQ': 'Soundcore Anker Life Q20',
    'B08YJ3W1HB': 'Bang & Olufsen Beoplay HX',
    'B0863FR3S9': 'Sony WH-1000XM4',
    'B07Q9MJKBV': 'Bose Headphones 700',
    'B07YVYZ8T5': 'Beats Solo3'
}

# Load the dataset (assuming 'Cleaned_Data.csv' contains your data)
reviews_df = pd.read_csv('/content/Cleaned_Data.csv')

# Function to calculate skewness and kurtosis
def calculate_skewness_kurtosis(df, column):
    skewness = skew(df[column].dropna())
    kurt = kurtosis(df[column].dropna())
    return skewness, kurt

# Get unique product IDs
product_ids = reviews_df['product_id'].unique()

# Loop through each product and calculate skewness, kurtosis, and visualize
for product_id in product_ids:
    product_df = reviews_df[reviews_df['product_id'] == product_id]

    # Calculate skewness and kurtosis for 'rating'
    skewness, kurt = calculate_skewness_kurtosis(product_df, 'rating')
    product_name = product_mapping.get(product_id, "Unknown Product")
    print(f"Product: {product_name}")
    print(f"Product ID: {product_id}")
    print(f"Skewness of 'rating': {skewness:.2f}")
    print(f"Kurtosis of 'rating': {kurt:.2f}")

    # Interpret skewness
    if skewness > 0:
        skewness_interpretation = "Positive Skew (Right Skew): More higher ratings that are infrequent"
    elif skewness < 0:
        skewness_interpretation = "Negative Skew (Left Skew): More lower ratings that are infrequent"
    else:
        skewness_interpretation = "No Skew: Symmetric distribution"

    # Interpret kurtosis
    if kurt > 0:
        kurtosis_interpretation = "Leptokurtic (Heavier tails): More outliers"
    elif kurt < 0:
        kurtosis_interpretation = "Platykurtic (Lighter tails): Fewer outliers"
    else:
        kurtosis_interpretation = "Mesokurtic (Normal distribution): Similar to normal distribution"

    print(f"Interpretation of Skewness: {skewness_interpretation}")
    print(f"Interpretation of Kurtosis: {kurtosis_interpretation}")
    print("\n")

    # Visualize the distribution using seaborn
    plt.figure(figsize=(10, 6))
    sns.histplot(product_df['rating'], kde=True, bins=30)
    plt.xlabel('Rating')
    plt.ylabel('Frequency')
    plt.title(f'Distribution of Ratings for {product_name} with KDE')
    plt.grid(True)
    plt.show()

"""Product Ratings Insights:
1. Bowers & Wilkins Px8 (Bowers & Wilkins)

Product ID: B0B349KKSV

Skewness: -0.69

Interpretation: Negative skew (left skew) indicating more frequent lower
ratings with some infrequent higher ratings.

Kurtosis: -1.12

Interpretation: Platykurtic (lighter tails) suggesting fewer extreme ratings, with most ratings clustered around the mean.
2. Beats Pro (DRE)

Product ID: B0C8PR4W22

Skewness: -1.26

Interpretation: Negative skew (left skew) showing a tendency for more frequent lower ratings, though high ratings are still present.

Kurtosis: 0.30

Interpretation: Leptokurtic (heavier tails) indicating more outliers, meaning there are some extreme ratings (both high and low).
3. Bang & Olufsen Beoplay HX

Product ID: B08YJ3W1HB

Skewness: -0.66

Interpretation: Negative skew (left skew) with more frequent lower ratings and some higher ratings that are infrequent.

Kurtosis: -0.98

Interpretation: Platykurtic (lighter tails) indicating fewer outliers and most ratings are closer to the mean.
4. Beats Solo3

Product ID: B07YVYZ8T5

Skewness: -1.03

Interpretation: Negative skew (left skew), suggesting that lower ratings are more frequent while higher ratings are less common.

Kurtosis: -0.32

Interpretation: Platykurtic (lighter tails) showing fewer extreme ratings compared to a normal distribution.
5. Bose Headphones 700

Product ID: B07Q9MJKBV

Skewness: -1.28

Interpretation: Negative skew (left skew) indicating that lower ratings are more common with some infrequent higher ratings.

Kurtosis: 1.17

Interpretation: Leptokurtic (heavier tails) suggesting more outliers and extreme ratings, both high and low.
6. Bose QuietComfort (BOSE)

Product ID: B0CCZ1L489

Skewness: -0.82

Interpretation: Negative skew (left skew) showing a greater frequency of lower ratings, with less frequent higher ratings.

Kurtosis: -0.72

Interpretation: Platykurtic (lighter tails) indicating fewer extreme ratings, with most clustered around the mean.
7. Momentum 4 (Sennheiser)


Product ID: B0B6GHW1SX

Skewness: -0.73

Interpretation: Negative skew (left skew), meaning that lower ratings are more frequent while higher ratings are less common.

Kurtosis: -0.53

Interpretation: Platykurtic (lighter tails) with fewer outliers and a distribution closer to the mean.
8. Sony XM5 (SONY)

Product ID: B0BXYCS74H

Skewness: -1.00

Interpretation: Negative skew (left skew) suggesting that lower ratings are more frequent with higher ratings being less common.

Kurtosis: -0.02

Interpretation: Platykurtic (lighter tails) indicating a lack of extreme ratings, with most ratings near the mean.

9. Sony WH-1000XM4

Product ID: B0863FR3S9

Skewness: -1.81

Interpretation: Strong negative skew (left skew) indicating a significant number of lower ratings with infrequent higher ratings.

Kurtosis: 3.60
Interpretation: Leptokurtic (heavier tails) showing more outliers, with extreme ratings being more frequent.
10. Soundcore Anker Life Q20


Product ID: B07NM3RSRQ

Skewness: -0.87

Interpretation: Negative skew (left skew) suggesting that lower ratings are more frequent while higher ratings are infrequent.

Kurtosis: -1.24

Interpretation: Platykurtic (lighter tails) with fewer extreme ratings and a more concentrated distribution around the mean.

Key Takeaways:

Negative Skew: Most products show negative skew, meaning lower ratings are more frequent. This indicates some dissatisfaction or issues that may be affecting the overall ratings.
Kurtosis Trends:

Platykurtic (Lighter Tails): Many products exhibit lighter tails, suggesting fewer extreme ratings.

Leptokurtic (Heavier Tails): Some products show heavier tails, indicating more frequent extreme ratings.
"""

# Define the product mapping dictionary
product_mapping = {
    'B0C8PR4W22': 'Beats Pro (DRE)',
    'B0BXYCS74H': 'Sony XM5 (SONY)',
    'B0B349KKSV': 'Bowers & Wilkins Px8 (Bowers & Wilkins)',
    'B0CCZ1L489': 'Bose QuietComfort (BOSE)',
    'B0B6GHW1SX': 'Momentum 4 (Sennheiser)',
    'B07NM3RSRQ': 'Soundcore Anker Life Q20',
    'B08YJ3W1HB': 'Bang & Olufsen Beoplay HX',
    'B0863FR3S9': 'Sony WH-1000XM4',
    'B07Q9MJKBV': 'Bose Headphones 700',
    'B07YVYZ8T5': 'Beats Solo3'
}

# Load the dataset (assuming 'Cleaned_Data.csv' contains your data)
reviews_df = pd.read_csv('/content/Cleaned_Data.csv')

# Function to perform sentiment analysis using TextBlob
def analyze_sentiment(text):
    blob = TextBlob(str(text))
    sentiment_score = blob.sentiment.polarity
    if sentiment_score > 0:
        return 'Positive'
    elif sentiment_score < 0:
        return 'Negative'
    else:
        return 'Neutral'

# Apply sentiment analysis to reviews and add 'sentiment' column
reviews_df['sentiment'] = reviews_df['content'].apply(analyze_sentiment)

# Get unique product IDs
product_ids = reviews_df['product_id'].unique()

# Loop through each product and calculate sentiment statistics
for product_id in product_ids:
    product_name = product_mapping.get(product_id, 'Unknown Product')
    product_df = reviews_df[reviews_df['product_id'] == product_id]

    # Calculate sentiment statistics
    sentiment_counts = product_df['sentiment'].value_counts()
    sentiment_stats = {
        'Product': product_name,
        'Positive': sentiment_counts.get('Positive', 0),
        'Negative': sentiment_counts.get('Negative', 0),
        'Neutral': sentiment_counts.get('Neutral', 0),
        'Total Reviews': len(product_df)
    }

    # Print or further process sentiment statistics as needed
    print(f"Sentiment statistics for {product_name}:")
    print(sentiment_stats)
    print()

"""***Conclusion Report on Product Ratings Analysis***

**Introduction**

This report analyzes the ratings of 10 headphone products to understand their performance and customer satisfaction levels. The analysis includes calculating the mean, median, mode, and variance of the ratings. Additionally, it examines the skewness and kurtosis of ratings for individual products to interpret the distribution and the presence of outliers. The correlation between ratings and helpfulness of reviews is also assessed.

**Summary of Mean Ratings**

The mean ratings for each product indicate overall customer satisfaction. Here are the average ratings:

Soundcore Anker Life Q20: 4.70
Bose Headphones 700: 4.06
Beats Solo3: 4.68
Sony WH-1000XM4: 4.60
Bang & Olufsen Beoplay HX: 3.69
Bowers & Wilkins Px8: 3.67
Momentum 4 (Sennheiser): 4.31
Sony XM5: 4.42
Beats Pro: 4.72
Bose QuietComfort: 4.41
Overall Mean Rating: 4.326
Median Rating: 5.0
Mode Rating: 5
Variance of Ratings: 1.0007

The high overall mean rating indicates that, on average, customers are quite satisfied with the products. The median and mode both being 5.0 suggest that many products received the highest possible ratings frequently. The variance shows moderate variability in the ratings.

**Correlation Analysis**

The correlation between the 'rating' and 'helpful_count' is -0.10, indicating a very weak negative relationship. This suggests that the helpfulness of a review does not significantly correlate with the rating given.

**Skewness and Kurtosis Analysis**

Skewness measures the asymmetry of the rating distribution, and kurtosis measures the tail heaviness. Here are the interpretations for each product:

Bowers & Wilkins Px8:
Skewness: -0.69 (Negative Skew)
Kurtosis: -1.12 (Platykurtic)
Beats Pro:
Skewness: -1.26 (Negative Skew)
Kurtosis: 0.30 (Leptokurtic)
Bang & Olufsen Beoplay HX:
Skewness: -0.66 (Negative Skew)
Kurtosis: -0.98 (Platykurtic)
Beats Solo3:
Skewness: -1.03 (Negative Skew)
Kurtosis: -0.32 (Platykurtic)
Bose Headphones 700:
Skewness: -1.28 (Negative Skew)
Kurtosis: 1.17 (Leptokurtic)
Bose QuietComfort:
Skewness: -0.82 (Negative Skew)
Kurtosis: -0.72 (Platykurtic)
Momentum 4 (Sennheiser):
Skewness: -0.73 (Negative Skew)
Kurtosis: -0.53 (Platykurtic)
Sony XM5:
Skewness: -1.00 (Negative Skew)
Kurtosis: -0.02 (Platykurtic)
Sony WH-1000XM4:
Skewness: -1.81 (Negative Skew)
Kurtosis: 3.60 (Leptokurtic)
Soundcore Anker Life Q20:
Skewness: -0.87 (Negative Skew)
Kurtosis: -1.24 (Platykurtic)
All products exhibit negative skewness, meaning they have more lower ratings that are less frequent. Products like Beats Pro and Sony WH-1000XM4 show leptokurtic distributions, indicating more outliers, whereas most other products show platykurtic distributions, indicating fewer outliers.

**Analysis and Recommendations**

High Customer Satisfaction: The overall high mean rating (4.326) suggests that customers are generally satisfied with these products.
Review Helpfulness: The weak correlation between ratings and helpfulness (-0.10) implies that review helpfulness is not a strong indicator of product satisfaction.
Product-Specific Insights: Products like Beats Pro and Sony WH-1000XM4 have more outliers, indicating varying customer experiences that might need further investigation to understand the cause of dissatisfaction.
Negative Skewness: All products show negative skewness, suggesting that while most ratings are high, there are occasional lower ratings that might be worth investigating to improve overall customer satisfaction.

**Conclusion**

This analysis highlights that while the overall customer satisfaction is high, there are nuances in the ratings distribution that suggest occasional dissatisfaction among some customers. Companies should focus on understanding and addressing the causes of these lower ratings to enhance product quality and customer satisfaction further. Additionally, leveraging customer feedback to improve product features and performance could lead to even higher ratings and better market positioning.


**Sentiment Analysis**

1. Bowers & Wilkins Px8 (Bowers & Wilkins)

Positive Reviews: 89%
Negative Reviews: 8%
Neutral Reviews: 3%
Interpretation: The product has a high percentage of positive reviews, but there are a notable number of negative reviews (8%), indicating some customer dissatisfaction.
2. Beats Pro (DRE)

Positive Reviews: 95%
Negative Reviews: 0%
Neutral Reviews: 5%
Interpretation: The product received overwhelmingly positive reviews with no negative feedback, suggesting very high customer satisfaction.
3. Bang & Olufsen Beoplay HX

Positive Reviews: 86%
Negative Reviews: 12%
Neutral Reviews: 2%
Interpretation: While the majority of reviews are positive, the relatively higher percentage of negative reviews (12%) indicates room for improvement.
4. Beats Solo3

Positive Reviews: 90%
Negative Reviews: 4%
Neutral Reviews: 6%
Interpretation: The product has a strong positive reception with few negative reviews, indicating general customer satisfaction.
5. Bose Headphones 700

Positive Reviews: 97%
Negative Reviews: 2%
Neutral Reviews: 1%
Interpretation: The product enjoys high customer satisfaction with minimal negative feedback.
6. Bose QuietComfort (BOSE)

Positive Reviews: 98%
Negative Reviews: 2%
Neutral Reviews: 0%
Interpretation: The product has an exceptionally high positive review rate, reflecting very high customer satisfaction.
7. Momentum 4 (Sennheiser)

Positive Reviews: 95%
Negative Reviews: 4%
Neutral Reviews: 1%
Interpretation: The product is well-received with a high percentage of positive reviews and minimal negative feedback.
8. Sony XM5 (SONY)

Positive Reviews: 95%
Negative Reviews: 1%
Neutral Reviews: 4%
Interpretation: The product has a high level of customer satisfaction with very few negative reviews.
9. Sony WH-1000XM4

Positive Reviews: 97%
Negative Reviews: 0%
Neutral Reviews: 3%
Interpretation: The product enjoys excellent customer satisfaction with no negative reviews.
10. Soundcore Anker Life Q20

Positive Reviews: 99%
Negative Reviews: 1%
Neutral Reviews: 0%
Interpretation: The product has the highest percentage of positive reviews, indicating exceptional customer satisfaction.


**Conclusion**

The sentiment analysis reveals that most products enjoy high levels of customer satisfaction, with positive reviews significantly outweighing negative and neutral reviews. The products with the highest satisfaction are the Soundcore Anker Life Q20 and Bose QuietComfort, while the Bang & Olufsen Beoplay HX and Bowers & Wilkins Px8 show relatively higher levels of negative feedback, indicating potential areas for improvement.

By addressing the concerns highlighted in the negative reviews, manufacturers can further enhance customer satisfaction and product quality. Overall, the sentiment analysis supports the conclusion that these headphone products are generally well-received by customers.
"""

def calculate_correlation(df, var1, var2):
    """
    Calculate the Pearson correlation coefficient between two variables in a dataset.

    :param df: DataFrame containing the data.
    :param var1: First variable (column name) for correlation calculation.
    :param var2: Second variable (column name) for correlation calculation.
    :return: Pearson correlation coefficient and p-value.
    """
    correlation, p_value = pearsonr(df[var1], df[var2])
    return correlation, p_value


def calculate_skewness_kurtosis(df, var):
    """
    Calculate the skewness and kurtosis of a variable in a dataset.

    :param df: DataFrame containing the data.
    :param var: Variable (column name) for skewness and kurtosis calculation.
    :return: Skewness and kurtosis values.
    """
    skewness = skew(df[var])
    kurt = kurtosis(df[var])
    return skewness, kurt

def analyze_sentiment(text):
    """
    Perform sentiment analysis on a given text using TextBlob.

    :param text: Text to analyze.
    :return: Sentiment category (Positive, Negative, Neutral).
    """
    blob = TextBlob(str(text))
    sentiment_score = blob.sentiment.polarity
    if sentiment_score > 0:
        return 'Positive'
    elif sentiment_score < 0:
        return 'Negative'
    else:
        return 'Neutral'

def sentiment_analysis_summary(df, text_column):
    """
    Perform sentiment analysis on a dataset of text reviews and return the counts of positive, negative, and neutral reviews.

    :param df: DataFrame containing the text data.
    :param text_column: Column name containing the text reviews.
    :return: Dictionary with counts of Positive, Negative, and Neutral reviews.
    """
    sentiments = df[text_column].apply(analyze_sentiment)
    sentiment_counts = sentiments.value_counts().to_dict()
    return {
        'Positive': sentiment_counts.get('Positive', 0),
        'Negative': sentiment_counts.get('Negative', 0),
        'Neutral': sentiment_counts.get('Neutral', 0)
    }


# Load the dataset
reviews_df = pd.read_csv('/content/Cleaned_Data.csv')

# Calculate correlation between two variables
correlation, p_value = calculate_correlation(reviews_df, 'rating', 'helpful_count')
print(f"Correlation between rating and helpful_count: {correlation}, p-value: {p_value}")

# Calculate skewness and kurtosis for the 'rating' variable
skewness, kurt = calculate_skewness_kurtosis(reviews_df, 'rating')
print(f"Skewness of rating: {skewness}, Kurtosis of rating: {kurt}")

# Perform sentiment analysis and get the summary
sentiment_summary = sentiment_analysis_summary(reviews_df, 'content')
print(f"Sentiment Analysis Summary: {sentiment_summary}")

